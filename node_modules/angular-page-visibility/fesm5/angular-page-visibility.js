import { __decorate, __metadata } from 'tslib';
import { ɵɵdefineInjectable, Injectable, Injector, NgModule } from '@angular/core';
import { Subject } from 'rxjs';

var AngularPageVisibilityStateEnum;
(function (AngularPageVisibilityStateEnum) {
    AngularPageVisibilityStateEnum[AngularPageVisibilityStateEnum["VISIBLE"] = 0] = "VISIBLE";
    AngularPageVisibilityStateEnum[AngularPageVisibilityStateEnum["HIDDEN"] = 1] = "HIDDEN";
    AngularPageVisibilityStateEnum[AngularPageVisibilityStateEnum["PRERENDER"] = 2] = "PRERENDER";
    AngularPageVisibilityStateEnum[AngularPageVisibilityStateEnum["UNLOADED"] = 3] = "UNLOADED";
})(AngularPageVisibilityStateEnum || (AngularPageVisibilityStateEnum = {}));

var HiddenKeyConstant = /** @class */ (function () {
    function HiddenKeyConstant() {
    }
    HiddenKeyConstant.DEFAULT = "hidden";
    HiddenKeyConstant.MS = "msHidden";
    HiddenKeyConstant.WEB_KIT = "webkitHidden";
    return HiddenKeyConstant;
}());
var VisibilityStatusConstant = /** @class */ (function () {
    function VisibilityStatusConstant() {
    }
    VisibilityStatusConstant.VISIBLE = "visible";
    VisibilityStatusConstant.HIDDEN = "hidden";
    VisibilityStatusConstant.PRERENDER = "prerender";
    VisibilityStatusConstant.UNLOADED = "unloaded";
    return VisibilityStatusConstant;
}());
var AngularPageVisibilityService = /** @class */ (function () {
    function AngularPageVisibilityService() {
        this.onPageVisibleSource = new Subject();
        this.onPageHiddenSource = new Subject();
        this.onPagePrerenderSource = new Subject();
        this.onPageUnloadedSource = new Subject();
        this.onPageVisibilityChangeSource = new Subject();
        this.$onPageVisible = this.onPageVisibleSource.asObservable();
        this.$onPageHidden = this.onPageHiddenSource.asObservable();
        this.$onPagePrerender = this.onPagePrerenderSource.asObservable();
        this.$onPageUnloaded = this.onPageUnloadedSource.asObservable();
        this.$onPageVisibilityChange = this.onPageVisibilityChangeSource.asObservable();
        this.addEventListenerVibilityChange();
    }
    AngularPageVisibilityService.prototype.isPageVisible = function () {
        return (VisibilityStatusConstant.VISIBLE === this.getVisibilityState() ||
            !this.isHidden());
    };
    AngularPageVisibilityService.prototype.isPageHidden = function () {
        return (VisibilityStatusConstant.HIDDEN === this.getVisibilityState() ||
            this.isHidden());
    };
    AngularPageVisibilityService.prototype.isPagePrerender = function () {
        return VisibilityStatusConstant.PRERENDER === this.getVisibilityState();
    };
    AngularPageVisibilityService.prototype.isPageUnloaded = function () {
        return VisibilityStatusConstant.UNLOADED === this.getVisibilityState();
    };
    AngularPageVisibilityService.prototype.isHidden = function () {
        return document[this.hidden];
    };
    AngularPageVisibilityService.prototype.getVisibilityState = function () {
        return document[this.visibilityState];
    };
    AngularPageVisibilityService.prototype.defineBrowserSupport = function () {
        if (typeof document[HiddenKeyConstant.DEFAULT] !== "undefined") {
            // Opera 12.10 and Firefox 18 and later support
            this.hidden = HiddenKeyConstant.DEFAULT;
            this.visibilityChange = "visibilitychange";
            this.visibilityState = "visibilityState";
        }
        else if (typeof document[HiddenKeyConstant.MS] !== "undefined") {
            this.hidden = HiddenKeyConstant.MS;
            this.visibilityChange = "msvisibilitychange";
            this.visibilityState = "msVisibilityState";
        }
        else if (typeof document[HiddenKeyConstant.WEB_KIT] !== "undefined") {
            this.hidden = HiddenKeyConstant.WEB_KIT;
            this.visibilityChange = "webkitvisibilitychange";
            this.visibilityState = "webkitVisibilityState";
        }
    };
    AngularPageVisibilityService.prototype.addEventListenerVibilityChange = function () {
        var _this = this;
        this.defineBrowserSupport();
        document.addEventListener(this.visibilityChange, function () {
            var vibilityState = _this.getVisibilityState();
            switch (vibilityState) {
                case VisibilityStatusConstant.VISIBLE:
                    _this.onPageVisibilityChangeSource.next(AngularPageVisibilityStateEnum.VISIBLE);
                    _this.onPageVisibleSource.next();
                    break;
                case VisibilityStatusConstant.HIDDEN:
                    _this.onPageVisibilityChangeSource.next(AngularPageVisibilityStateEnum.HIDDEN);
                    _this.onPageHiddenSource.next();
                    break;
                case VisibilityStatusConstant.PRERENDER:
                    _this.onPageVisibilityChangeSource.next(AngularPageVisibilityStateEnum.PRERENDER);
                    _this.onPagePrerenderSource.next();
                    break;
                case VisibilityStatusConstant.UNLOADED:
                    _this.onPageVisibilityChangeSource.next(AngularPageVisibilityStateEnum.UNLOADED);
                    _this.onPageUnloadedSource.next();
                    break;
                default:
                    if (_this.isHidden()) {
                        _this.onPageVisibilityChangeSource.next(AngularPageVisibilityStateEnum.HIDDEN);
                        _this.onPageHiddenSource.next();
                    }
                    else {
                        _this.onPageVisibilityChangeSource.next(AngularPageVisibilityStateEnum.VISIBLE);
                        _this.onPageVisibleSource.next();
                    }
            }
        }, false);
    };
    AngularPageVisibilityService.ɵprov = ɵɵdefineInjectable({ factory: function AngularPageVisibilityService_Factory() { return new AngularPageVisibilityService(); }, token: AngularPageVisibilityService, providedIn: "root" });
    AngularPageVisibilityService = __decorate([
        Injectable({
            providedIn: "root"
        }),
        __metadata("design:paramtypes", [])
    ], AngularPageVisibilityService);
    return AngularPageVisibilityService;
}());

var providers = [
    { provide: AngularPageVisibilityService, deps: [] },
];
var injector = Injector.create({ providers: providers });
var pageVisibilityService = injector.get(AngularPageVisibilityService);
function OnPageVisibilityChange() {
    return function (target, propertyKey, descriptor) {
        var originalMethod = descriptor.value;
        var onPageHiddenSubscription;
        if (!target.ngOnInit) {
            buildNewMethodNgOnInit(target);
        }
        var originalNgOnInit = target.ngOnInit;
        target.ngOnInit = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            onPageHiddenSubscription = pageVisibilityService.$onPageVisibilityChange.subscribe(function (visibilityState) {
                return originalMethod.call(_this, [visibilityState]);
            });
            if (originalNgOnInit) {
                originalNgOnInit.call(this, args);
            }
        };
        if (!target.ngOnDestroy) {
            buildNewMethodNgOnDestroy(target);
        }
        var originalNgOnDestroy = target.ngOnDestroy;
        target.ngOnDestroy = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            onPageHiddenSubscription.unsubscribe();
            if (originalNgOnDestroy) {
                originalNgOnDestroy.call(this, args);
            }
        };
    };
}
function OnPageHidden() {
    return function (target, propertyKey, descriptor) {
        var originalMethod = descriptor.value;
        var onPageHiddenSubscription;
        if (!target.ngOnInit) {
            buildNewMethodNgOnInit(target);
        }
        var originalNgOnInit = target.ngOnInit;
        target.ngOnInit = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            onPageHiddenSubscription = pageVisibilityService.$onPageHidden.subscribe(function () { return originalMethod.call(_this); });
            if (originalNgOnInit) {
                originalNgOnInit.call(this, args);
            }
        };
        if (!target.ngOnDestroy) {
            buildNewMethodNgOnDestroy(target);
        }
        var originalNgOnDestroy = target.ngOnDestroy;
        target.ngOnDestroy = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            onPageHiddenSubscription.unsubscribe();
            if (originalNgOnDestroy) {
                originalNgOnDestroy.call(this, args);
            }
        };
    };
}
function OnPageVisible() {
    return function (target, propertyKey, descriptor) {
        var originalMethod = descriptor.value;
        if (!target.ngOnInit) {
            buildNewMethodNgOnInit(target);
        }
        var originalNgOnInit = target.ngOnInit;
        var onPageVisibleSubscription;
        target.ngOnInit = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            onPageVisibleSubscription = pageVisibilityService.$onPageVisible.subscribe(function () { return originalMethod.call(_this); });
            if (originalNgOnInit) {
                originalNgOnInit.call(this, args);
            }
        };
        if (!target.ngOnDestroy) {
            buildNewMethodNgOnDestroy(target);
        }
        var originalNgOnDestroy = target.ngOnDestroy;
        target.ngOnDestroy = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            onPageVisibleSubscription.unsubscribe();
            if (originalNgOnDestroy) {
                originalNgOnDestroy.call(this, args);
            }
        };
    };
}
function OnPagePrerender() {
    return function (target, propertyKey, descriptor) {
        var originalMethod = descriptor.value;
        var onPagePrerenderSubscription;
        if (!target.ngOnInit) {
            buildNewMethodNgOnInit(target);
        }
        var originalNgOnInit = target.ngOnInit;
        target.ngOnInit = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            onPagePrerenderSubscription = pageVisibilityService.$onPagePrerender.subscribe(function () { return originalMethod.call(_this); });
            if (originalNgOnInit) {
                originalNgOnInit.call(this, args);
            }
        };
        if (!target.ngOnDestroy) {
            buildNewMethodNgOnDestroy(target);
        }
        var originalNgOnDestroy = target.ngOnDestroy;
        target.ngOnDestroy = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            onPagePrerenderSubscription.unsubscribe();
            if (originalNgOnDestroy) {
                originalNgOnDestroy.call(this, args);
            }
        };
    };
}
function OnPageUnloaded() {
    return function (target, propertyKey, descriptor) {
        var originalMethod = descriptor.value;
        var onPageUnloadedSubscription;
        if (!target.ngOnInit) {
            buildNewMethodNgOnInit(target);
        }
        var originalNgOnInit = target.ngOnInit;
        target.ngOnInit = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            onPageUnloadedSubscription = pageVisibilityService.$onPageUnloaded.subscribe(function () { return originalMethod.call(_this); });
            if (originalNgOnInit) {
                originalNgOnInit.call(this, args);
            }
        };
        if (!target.ngOnDestroy) {
            buildNewMethodNgOnDestroy(target);
        }
        var originalNgOnDestroy = target.ngOnDestroy;
        target.ngOnDestroy = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            onPageUnloadedSubscription.unsubscribe();
            if (originalNgOnDestroy) {
                originalNgOnDestroy.call(this, args);
            }
        };
    };
}
function buildNewMethodNgOnInit(target) {
    newMethod(target, 'ngOnInit');
}
function buildNewMethodNgOnDestroy(target) {
    newMethod(target, 'ngOnDestroy');
}
function newMethod(target, name) {
    Object.defineProperty(target, name, {
        value: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
        },
        writable: true,
    });
}

var AngularPageVisibilityModule = /** @class */ (function () {
    function AngularPageVisibilityModule() {
    }
    AngularPageVisibilityModule = __decorate([
        NgModule({
            imports: [],
            declarations: [],
            providers: [AngularPageVisibilityService],
            exports: []
        })
    ], AngularPageVisibilityModule);
    return AngularPageVisibilityModule;
}());

/*
 * Public API Surface of angular-page-visibility-lib
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AngularPageVisibilityModule, AngularPageVisibilityService, AngularPageVisibilityStateEnum, OnPageHidden, OnPagePrerender, OnPageUnloaded, OnPageVisibilityChange, OnPageVisible };
//# sourceMappingURL=angular-page-visibility.js.map
